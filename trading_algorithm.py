# -*- coding: utf-8 -*-
"""Trading Algorithm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15PncjAGMh-knrvnO05DeOshlM28bptyY
"""

# Libraries
import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Settings
symbol = 'AMZN'  # Type the desired company within single quotes
timeframe = '1d'  # Use string '1d' for daily timeframe
num_bars = 100  # Number of bars you want to retrieve

# Requesting historical data
bars = yf.download(symbol, interval=timeframe)
df = bars.iloc[-num_bars:].reset_index()

# Selecting required columns
df = df[['Date', 'Open', 'High', 'Low', 'Close']]
df.columns = ['time', 'open', 'high', 'low', 'close']  # renaming columns
df['time'] = pd.to_datetime(df['time'])

print(df)

# Plotting the close prices
plt.figure(figsize=(12, 6))
plt.plot(df['time'], df['close'], marker='o')
plt.title(f'{symbol} - Close Prices')
plt.xlabel('Time')
plt.ylabel('Close Price')
plt.grid(True)
plt.show()

# Setting the RSI Period
rsi_period = 14

# Calculating gains and losses
df['gain'] = (df['close'] - df['open']).apply(lambda x: x if x > 0 else 0)
df['loss'] = (df['close'] - df['open']).apply(lambda x: -x if x < 0 else 0)

# Calculating exponential moving averages for gains and losses
df['ema_gain'] = df['gain'].ewm(span=rsi_period, min_periods=rsi_period).mean()
df['ema_loss'] = df['loss'].ewm(span=rsi_period, min_periods=rsi_period).mean()

# Calculating the Relative Strength (RS)
df['rs'] = df['ema_gain'] / df['ema_loss']

# Calculating the Relative Strength Index (RSI)
df['rsi_14'] = 100 - (100 / (df['rs'] + 1))

# Displaying the results
print(df[['time', 'rsi_14', 'rs', 'ema_gain', 'ema_loss']])

# Plotting the RSI
plt.figure(figsize=(12, 6))
plt.plot(df['time'], df['rsi_14'], marker='o')
plt.title(f'{symbol} - RSI Indicator')
plt.xlabel('Time')
plt.ylabel('RSI')
plt.axhline(y=70, color='r', linestyle='--')  # Overbought level
plt.axhline(y=30, color='g', linestyle='--')  # Oversold level
plt.grid(True)
plt.show()

# Setting the ATR Period
atr_period = 14

# Calculating the range of each candle
df['range'] = df['high'] - df['low']

# Calculating the average value of ranges
df['atr_14'] = df['range'].rolling(atr_period).mean()

# Displaying the ATR
print(df[['time', 'atr_14']])

# Plotting the ATR Indicator
plt.figure(figsize=(12, 6))
plt.plot(df['time'], df['atr_14'], marker='o')
plt.title(f'{symbol} - ATR Indicator')
plt.xlabel('Time')
plt.ylabel('ATR')
plt.grid(True)
plt.show()

# Class Position for backtesting trades
class Position:
    def __init__(self, open_datetime, open_price, order_type, volume, sl, tp):
        self.open_datetime = open_datetime
        self.open_price = open_price
        self.order_type = order_type
        self.volume = volume
        self.sl = sl
        self.tp = tp
        self.close_datetime = None
        self.close_price = None
        self.profit = None
        self.status = 'open'

    def close_position(self, close_datetime, close_price):
        self.close_datetime = close_datetime
        self.close_price = close_price
        self.profit = (self.close_price - self.open_price) * self.volume if self.order_type == 'buy' \
            else (self.open_price - self.close_price) * self.volume
        self.status = 'closed'

    def _asdict(self):
        return {
            'open_datetime': self.open_datetime,
            'open_price': self.open_price,
            'order_type': self.order_type,
            'volume': self.volume,
            'sl': self.sl,
            'tp': self.tp,
            'close_datetime': self.close_datetime,
            'close_price': self.close_price,
            'profit': self.profit,
            'status': self.status,
        }

# Class Strategy defines trading logic and evaluates the backtest based on opened/closed positions
class Strategy:
    def __init__(self, df, starting_balance):
        self.starting_balance = starting_balance
        self.positions = []
        self.data = df

    # Return backtest result
    def get_positions_df(self):
        df = pd.DataFrame([position._asdict() for position in self.positions])
        df['pnl'] = df['profit'].cumsum() + self.starting_balance
        return df

    # Add Position class to list
    def add_position(self, position):
        self.positions.append(position)
        return True

    # Close positions when stop loss or take profit is reached
    def close_tp_sl(self, data):
        for pos in self.positions:
            if pos.status == 'open':
                if (pos.sl >= data.close and pos.order_type == 'buy'):
                    pos.close_position(data.time, pos.sl)
                elif (pos.sl <= data.close and pos.order_type == 'sell'):
                    pos.close_position(data.time, pos.sl)
                elif (pos.tp <= data.close and pos.order_type == 'buy'):
                    pos.close_position(data.time, pos.tp)
                elif (pos.tp >= data.close and pos.order_type == 'sell'):
                    pos.close_position(data.time, pos.tp)

    # Check for open positions
    def has_open_positions(self):
        for pos in self.positions:
            if pos.status == 'open':
                return True
        return False

    # Strategy logic how positions should be opened/closed
    def logic(self, data):
        # If no position is open
        if not self.has_open_positions():
            # If RSI less than 30 -> BUY
            if data['rsi_14'] < 30:
                # Position variables
                open_datetime = data['time']
                open_price = data['close']
                order_type = 'buy'
                volume = 10000
                sl = open_price - 2 * data['atr_14']
                tp = open_price + 2 * data['atr_14']
                self.add_position(Position(open_datetime, open_price, order_type, volume, sl, tp))

            # If RSI greater than 70 -> SELL
            elif data['rsi_14'] > 70:
                # Position variables
                open_datetime = data['time']
                open_price = data['close']
                order_type = 'sell'
                volume = 10000
                sl = open_price + 2 * data['atr_14']
                tp = open_price - 2 * data['atr_14']
                self.add_position(Position(open_datetime, open_price, order_type, volume, sl, tp))

    # Run the backtest
    def run(self):
        # Data represents a moment in time while iterating through the backtest
        for i, data in self.data.iterrows():
            # Close positions when stop loss or take profit is reached
            self.close_tp_sl(data)
            # Strategy logic
            self.logic(data)
        return self.get_positions_df()

# Preparing data for backtest
backtest_df = df[14:]  # Removing NaN values
print(backtest_df)

# Creating an instance of Strategy class
rsi_strategy = Strategy(backtest_df, 10000)

# Running the backtest
backtest_result = rsi_strategy.run()

print(backtest_result)
# Analyzing closed positions only
backtest_result = backtest_result[backtest_result['status'] == 'closed']

# Visualizing trades
plt.figure(figsize=(12, 6))
plt.plot(df['time'], df['close'], label='Close Price')
for i, position in backtest_result.iterrows():
    if position.status == 'closed':
        color = 'green' if position.profit >= 0 else 'red'
        plt.plot([position.open_datetime, position.close_datetime],
                 [position.open_price, position.close_price], color=color, linewidth=2)
plt.title('RSI Strategy - Trades')
plt.xlabel('Time')
plt.ylabel('Price')
plt.legend()
plt.grid(True)
plt.show()

# Plotting PnL
plt.figure(figsize=(12, 6))
plt.plot(backtest_result['close_datetime'], backtest_result['pnl'])
plt.title('RSI Strategy - PnL')
plt.xlabel('Time')
plt.ylabel('PnL')
plt.grid(True)
plt.show()

# Calculate daily returns
backtest_result['daily_returns'] = backtest_result['pnl'].pct_change()

# Calculate Sharpe ratio
sharpe_ratio = backtest_result['daily_returns'].mean() / backtest_result['daily_returns'].std() * np.sqrt(252)
print(f"Sharpe Ratio: {sharpe_ratio:.2f}")

# Calculate maximum drawdown
backtest_result['cumulative_returns'] = (1 + backtest_result['daily_returns']).cumprod()
max_drawdown = (backtest_result['cumulative_returns'].cummax() - backtest_result['cumulative_returns']) / backtest_result['cumulative_returns'].cummax()
max_drawdown = max_drawdown.max()
print(f"Maximum Drawdown: {max_drawdown:.2%}")

# Calculate total return
total_return = (backtest_result['pnl'].iloc[-1] - backtest_result['pnl'].iloc[0]) / backtest_result['pnl'].iloc[0]
print(f"Total Return: {total_return:.2%}")